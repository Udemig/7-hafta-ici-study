{
  "version": 3,
  "sources": ["../../millify/dist/options.js", "../../millify/dist/utils.js", "../../millify/dist/millify.js"],
  "sourcesContent": ["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.defaultOptions = void 0;\n/**\n * Default options for Millify.\n */\nexports.defaultOptions = {\n    lowercase: false,\n    precision: 1,\n    space: false,\n    units: [\n        \"\",\n        \"K\",\n        \"M\",\n        \"B\",\n        \"T\",\n        \"P\",\n        \"E\", // Quintillion\n    ],\n};\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getLocales = exports.getFractionDigits = exports.roundTo = exports.parseValue = void 0;\n/**\n * parseValue ensures the value is a number and within accepted range.\n */\nfunction parseValue(value) {\n    const val = parseFloat(value === null || value === void 0 ? void 0 : value.toString());\n    if (isNaN(val)) {\n        throw new Error(`Input value is not a number`);\n    }\n    if (val > Number.MAX_SAFE_INTEGER || val < Number.MIN_SAFE_INTEGER) {\n        throw new RangeError(\"Input value is outside of safe integer range\");\n    }\n    return val;\n}\nexports.parseValue = parseValue;\n/**\n * Rounds a number [value] up to a specified [precision].\n */\nfunction roundTo(value, precision) {\n    if (!Number.isFinite(value)) {\n        throw new Error(\"Input value is not a finite number\");\n    }\n    if (!Number.isInteger(precision) || precision < 0) {\n        throw new Error(\"Precision is not a positive integer\");\n    }\n    if (Number.isInteger(value)) {\n        return value;\n    }\n    return parseFloat(value.toFixed(precision));\n}\nexports.roundTo = roundTo;\n/**\n * Returns the number of digits after the decimal.\n */\nfunction getFractionDigits(num) {\n    var _a;\n    if (Number.isInteger(num)) {\n        return 0;\n    }\n    const decimalPart = num.toString().split(\".\")[1];\n    return (_a = decimalPart === null || decimalPart === void 0 ? void 0 : decimalPart.length) !== null && _a !== void 0 ? _a : 0;\n}\nexports.getFractionDigits = getFractionDigits;\n/**\n * Returns the default browser locales.\n */\nfunction getLocales() {\n    var _a;\n    if (typeof navigator === \"undefined\") {\n        return [];\n    }\n    return Array.from((_a = navigator.languages) !== null && _a !== void 0 ? _a : []);\n}\nexports.getLocales = getLocales;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.millify = void 0;\nconst options_1 = require(\"./options\");\nconst utils_1 = require(\"./utils\");\n// Most commonly used digit grouping base.\nconst DIGIT_GROUPING_BASE = 1000;\n/**\n * Generator that divides a number until a decimal value is found.\n *\n * The denominator is defined by the numerical digit grouping base,\n * or interval. The most commonly-used digit group interval is 1000.\n *\n * e.g. 1,000,000 is grouped in multiples of 1000.\n */\nfunction* divider(value) {\n    // Create a mutable copy of the base.\n    let denominator = DIGIT_GROUPING_BASE;\n    while (true) {\n        const result = value / denominator;\n        if (result < 1) {\n            // End of operation. We can't divide the value any further.\n            return;\n        }\n        yield result;\n        // The denominator is increased every iteration by multiplying\n        // the base by itself, until a decimal value remains.\n        denominator *= DIGIT_GROUPING_BASE;\n    }\n}\n/**\n * millify converts long numbers to human-readable strings.\n */\nfunction millify(value, options) {\n    var _a, _b;\n    // Override default options with options supplied by user.\n    const opts = options\n        ? { ...options_1.defaultOptions, ...options }\n        : options_1.defaultOptions;\n    if (!Array.isArray(opts.units) || !opts.units.length) {\n        throw new Error(\"Option `units` must be a non-empty array\");\n    }\n    // If the input value is invalid, then return the value in string form.\n    // Originally this threw an error, but was changed to return a graceful fallback.\n    let val;\n    try {\n        val = utils_1.parseValue(value);\n    }\n    catch (e) {\n        if (e instanceof Error) {\n            console.warn(`WARN: ${e.message} (millify)`);\n        }\n        // Invalid values will be converted to string as per `String()`.\n        return String(value);\n    }\n    // Add a minus sign (-) prefix if it's a negative number.\n    const prefix = val < 0 ? \"-\" : \"\";\n    // Work only with positive values for simplicity's sake.\n    val = Math.abs(val);\n    // Keep dividing the input value by the digit grouping base\n    // until the decimal and the unit index is deciphered.\n    let unitIndex = 0;\n    for (const result of divider(val)) {\n        val = result;\n        unitIndex += 1;\n    }\n    // Return the original number if the number is too large to have\n    // a corresponding unit. Returning anything else is ambiguous.\n    const unitIndexOutOfRange = unitIndex >= opts.units.length;\n    if (unitIndexOutOfRange) {\n        // At this point we don't know what to do with the input value,\n        // so we return it as is, without localizing the string.\n        return value.toString();\n    }\n    // Round decimal up to desired precision.\n    let rounded = utils_1.roundTo(val, opts.precision);\n    // Fixes an edge case bug that outputs certain numbers as 1000K instead of 1M.\n    // The rounded value needs another iteration in the divider cycle.\n    for (const result of divider(rounded)) {\n        rounded = result;\n        unitIndex += 1;\n    }\n    // Calculate the unit suffix and make it lowercase (if needed).\n    const unit = (_a = opts.units[unitIndex]) !== null && _a !== void 0 ? _a : \"\";\n    const suffix = opts.lowercase ? unit.toLowerCase() : unit;\n    // Add a space between number and abbreviation.\n    const space = opts.space ? \" \" : \"\";\n    // Format the number according to the desired locale.\n    const formatted = rounded.toLocaleString((_b = opts.locales) !== null && _b !== void 0 ? _b : utils_1.getLocales(), {\n        // toLocaleString needs the explicit fraction digits.\n        minimumFractionDigits: utils_1.getFractionDigits(rounded),\n    });\n    return `${prefix}${formatted}${space}${suffix}`;\n}\nexports.millify = millify;\nexports.default = millify;\n"],
  "mappings": "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",
  "names": []
}
